<!DOCTYPE html>
<html>
<head>
    <title>mcnultydalbamead_3210_project3</title>
</head>
<body>

    <canvas id="myCanvas"></canvas>

    <script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import Deck from './components/deck.js';

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0, 9, 6);
camera.lookAt( new THREE.Vector3(0.0,6.0,2.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

 // Light Setup
 const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
 scene.add(ambientLight);
 
 const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
 directionalLight.position.y = 10;
 directionalLight.castShadow = true;
 directionalLight.shadow.mapSize.width = 1024;
 directionalLight.shadow.mapSize.length = 1024;


 scene.add(directionalLight);

 const gltfLoader = new GLTFLoader();
 gltfLoader.load('./components/kitchen_table.glb', function(glb) {
    const model = glb.scene;
    scene.add(model);
    model.rotateY(Math.PI / 2);
    model.scale.set(0.4, 0.4, 0.4);
    model.position.set(0.25, 0.15, 0);

    model.traverse(function(node) {
        if(node.isMesh)
            node.receiveShadow = true;
    })

 });

 // Create and shuffle deck
const deck = new Deck();
deck.shuffle();
const piles = deck.deal(3);

const tableSurfaceHeight = 3.6311214951294932;
const cardOffsetAboveTable = 1; // Small offset above the table surface

// Position each player's pile slightly above the table surface
const pilePositions = [
    new THREE.Vector3(-1.5, tableSurfaceHeight + cardOffsetAboveTable, -2.5), // Player 1
    new THREE.Vector3(1.5, tableSurfaceHeight + cardOffsetAboveTable, -2.5),  // Player 2
    new THREE.Vector3(0, tableSurfaceHeight + cardOffsetAboveTable, 2.5)      // Player 3
];

// Game state
let currentCards = [];
let activePlayers = piles.map((_, i) => i);

// Flip cards and determine winner
function playRound() {
    currentCards = activePlayers.map(i => piles[i].pop());
    currentCards.forEach((card, index) => card.obj.position.set(pilePositions[index].x, pilePositions[index].y + 1, pilePositions[index].z));

    // Determine highest card
    let maxVal = Math.max(...currentCards.map(card => card.value));
    let winners = currentCards.filter(card => card.value === maxVal);
    if (winners.length > 1) {
        // War logic for ties
        console.log('War!');
    } else {
        // Award cards to winner
        console.log('Player ' + activePlayers[currentCards.findIndex(card => card.value === maxVal)] + ' wins the round');
    }

    // Check for game end
    if (piles.some(pile => pile.length === 51)) {
        console.log('Game over!');
    }
}

window.addEventListener('keydown', event => {
    if (event.key === 'n') playRound();
    flipTopCards();
});

function flipTopCards() {
    playerPositions.forEach((position, index) => {
        const topCard = deck[index * Math.floor(deck.length / playerPositions.length)];

        // Rotate top card to face up
        if (topCard) {
            topCard.obj.rotation.y = Math.PI; // Rotate 180 degrees to show front texture
            topCard.obj.position.y += 0.1;    
        }
    });

    // Logic for determining the winner of the round can be added here
}
// Render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    console.log("Rendering..."); // Add this line to confirm the loop is running

}
animate();    
</script>
</body>
</html>
