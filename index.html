<!DOCTYPE html>
<html>
<head>
    <title>mcnultydalbamead_3210_project3</title>
</head>
<body>

    <canvas id="myCanvas"></canvas>

    <script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import Deck from './components/deck.js';

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0, 9, 6);
camera.lookAt( new THREE.Vector3(0.0,6.0,2.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

 // Light Setup
 const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
 scene.add(ambientLight);
 
 const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
 directionalLight.position.y = 10;
 directionalLight.castShadow = true;
 directionalLight.shadow.mapSize.width = 1024;
 directionalLight.shadow.mapSize.length = 1024;


 scene.add(directionalLight);

 // Create a new deck and deal cards
const deck = new Deck();
deck.shuffle(); // Shuffle the deck
const playersCount = 3; // Number of players
const piles = deck.deal(playersCount); // Create piles for each player


 const gltfLoader = new GLTFLoader();
 gltfLoader.load('./components/kitchen_table.glb', function(glb) {
    const model = glb.scene;
    scene.add(model);
    model.rotateY(Math.PI / 2);
    model.scale.set(0.4, 0.4, 0.4);
    model.position.set(0.25, 0.15, 0);

    model.traverse(function(node) {
        if(node.isMesh) {
            node.receiveShadow = true;
        }
    })
    positionCards();
 });

 function positionCards() {
    // Check if piles are created
    if (piles.length === 0) {
        console.log("No piles available.");
        return;
    }

      // Create positions for the cards
      const pilePositions = [
      new THREE.Vector3(-1.5, 4, -1.25), // Adjusted Y for height above table
      new THREE.Vector3(1.5, 4, -1.25),
      new THREE.Vector3(0, 4, 1.75)
  ];

     // Position the cards for each player
     piles.forEach((pile, index) => {
        pile.forEach((card, cardIndex) => {
            const position = pilePositions[index];
            const offset = cardIndex * 0.005; // Stacking cards vertically

            // Position the card
            card.obj.position.set(position.x, position.y + offset, position.z);
            card.obj.scale.set(1, 1, 1); // Ensure cards are not scaled down
            card.obj.rotateX(90);
            scene.add(card.obj);

            // Debugging: Log card information
            console.log(`Positioned card ${cardIndex} for player ${index}:`, {
                position: card.obj.position,
                scale: card.obj.scale,
                visible: card.obj.visible,
            });
        });
    });
}

let centerPositions = [
    new THREE.Vector3(-0.5, 4, 0), // Position for Player 1's card in center
    new THREE.Vector3(0.5, 4, 0),  // Position for Player 2's card in center
    new THREE.Vector3(0, 4, -0.5)  // Position for Player 3's card in center
];
let displayedCards = []; // Store cards in the current round

function animateCardMove(card, targetPosition) {
    const moveDuration = 1000; // 1-second animation for moving to the center
    const flipDuration = 500;  // Half-second animation for the flip
    const startPos = card.position.clone();
    const startTime = Date.now();

    // Set the initial rotation to face down
    card.rotation.set(Math.PI / 2, 0, 0); // Start with the card facing down

    // First phase: Move the card to the center
    function moveToCenter() {
        const elapsedTime = Date.now() - startTime;
        const t = Math.min(elapsedTime / moveDuration, 1);

        // Move the card to the center position
        card.position.lerpVectors(startPos, targetPosition, t);

        if (t < 1) {
            requestAnimationFrame(moveToCenter);
        } else {
            // Once at the center, start the flip after a brief delay
            setTimeout(flipCard, 200); // Delay before flipping
        }
    }

    // Second phase: Flip the card to show the face-up side
    function flipCard() {
        const flipStartTime = Date.now();

        function animateFlip() {
            const flipElapsed = Date.now() - flipStartTime;
            const t = Math.min(flipElapsed / flipDuration, 1);

            // Rotate the card along the X-axis to flip it 180 degrees (face-up)
            card.rotation.x = Math.PI / 2 * (1 - t); // Ends at 0 (face-up)

            if (t < 1) {
                requestAnimationFrame(animateFlip);
            } else {
                // Ensure it finishes exactly face-up and above the table
                card.rotation.x = 0; // Face-up
                card.position.y = targetPosition.y + 0.01; // Slightly above table height
            }
        }
        animateFlip();
    }

    // Start the movement to the center
    moveToCenter();
}

function handleRound() {
    const cardsThisRound = piles.map((pile, index) => {
        if (pile.length > 0) {
            const card = pile.pop();
            displayedCards.push(card); // Track displayed cards on the table
            animateCardMove(card.obj, centerPositions[index]); // Animate card to center
            return { owner: index, card: card };
        }
        return null; // If no cards, mark player as out
    });

    // Filter out players who still have cards in this round
    const activePlayers = cardsThisRound.filter(entry => entry !== null);
    if (activePlayers.length < 2) {
        console.log(`Game over! Player ${activePlayers[0] ? activePlayers[0].owner + 1 : 'unknown'} wins!`);
        return;
    }

    // Determine if there's a tie for the highest card
    const maxCardValue = Math.max(...activePlayers.map(entry => entry.card.value));
    const highestCards = activePlayers.filter(entry => entry.card.value === maxCardValue);

    if (highestCards.length === 1) {
        // Single winner: move all displayed cards to the winner's pile
        const winnerIndex = highestCards[0].owner;
        console.log(`Player ${winnerIndex + 1} wins this round!`); // Log winner
        if (piles[winnerIndex]) { // Ensure winner's pile exists
            piles[winnerIndex].unshift(...displayedCards);
            console.log(`Added ${displayedCards.length} cards to Player ${winnerIndex + 1}'s pile.`);
        } else {
            console.error(`Winner index ${winnerIndex} is out of bounds for piles array.`);
        }
        displayedCards = []; // Clear cards on the table
    } else {
        // Tie detected - initiate a war
        console.log("War initiated!");
        handleWar(highestCards.map(entry => entry.owner));
    }
}

function handleWar(playersInWar) {
    console.log("War initiated!");

    const warCards = [];
    playersInWar.forEach(playerIndex => {
        if (piles[playerIndex].length < 2) {
            // Player has fewer than 2 cards - use last available card as final face-up
            const finalCard = piles[playerIndex].pop();
            if (finalCard) {
                displayedCards.push(finalCard);
                warCards.push({ owner: playerIndex, card: finalCard });
                animateCardMove(finalCard.obj, centerPositions[playerIndex]);
            }
        } else {
            // Normal war play: one face-down and one face-up card
            const faceDownCard = piles[playerIndex].pop();
            displayedCards.push(faceDownCard);
            
            const faceUpCard = piles[playerIndex].pop();
            displayedCards.push(faceUpCard);
            warCards.push({ owner: playerIndex, card: faceUpCard });
            animateCardMove(faceUpCard.obj, centerPositions[playerIndex]);
        }
    });

    // Active players in the war with cards on the table
    const activeWarPlayers = warCards.filter(warCard => warCard !== null);
    if (activeWarPlayers.length < 2) {
        // Only one player remains after the war
        const solePlayer = activeWarPlayers[0].owner;
        piles[solePlayer].unshift(...displayedCards);
        displayedCards = [];
        console.log(`Player ${solePlayer + 1} wins all cards in the war!`);
        return;
    }

    // Check if there's a tie among war cards
    const maxWarValue = Math.max(...activeWarPlayers.map(warCard => warCard.card.value));
    const highestWarCards = activeWarPlayers.filter(warCard => warCard.card.value === maxWarValue);

    if (highestWarCards.length === 1) {
        // War winner
        const warWinner = highestWarCards[0].owner;
        piles[warWinner].unshift(...displayedCards);
        displayedCards = [];
        console.log(`Player ${warWinner + 1} wins all cards in the war!`);
    } else {
        // War continues with new face-down and face-up cards
        handleWar(highestWarCards.map(warCard => warCard.owner));
    }
}

// Key listener to start the round
document.addEventListener("keydown", (event) => {
    if (event.key === 'N' || event.key === 'n') {
        handleRound();
    }
});

// Render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);

}
animate();    
</script>
</body>
</html>
