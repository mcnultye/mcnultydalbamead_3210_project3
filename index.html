<!DOCTYPE html>
<html>
<head>
    <title>mcnultydalbamead_3210_project3</title>
</head>
<body>
    <div id="scoreBoard">
        <p>Player 1 Cards: <span id="player1Score">17</span></p>
        <p>Player 2 Cards: <span id="player2Score">17</span></p>
        <p>Player 3 Cards: <span id="player3Score">17</span></p>
    </div>

    <canvas id="myCanvas"></canvas>

    <script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import Deck from './components/deck.js';

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0, 9, 6);
camera.lookAt( new THREE.Vector3(0.0,6.0,2.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;

 // Light Setup
 var lights = []
 const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
 ambientLight.castShadow = true;
 lights.push(ambientLight);
 scene.add(ambientLight);
 
 const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
 directionalLight.position.y = 10;
 directionalLight.castShadow = true;
 directionalLight.shadow.mapSize.width = 1024;
 directionalLight.shadow.mapSize.length = 1024;

 lights.push(directionalLight);
 scene.add(directionalLight);

 // Create a new deck and deal cards
const deck = new Deck();
deck.shuffle(); // Shuffle the deck
const playersCount = 3; // Number of players

const cardsPerPlayer = Math.floor(deck.deck.length / playersCount);
const totalCards = cardsPerPlayer * playersCount;

// Discard extra cards so the deck divides evenly among players
deck.deck = deck.deck.slice(0, totalCards);

// Initialize piles for each player
const piles = Array.from({ length: playersCount }, () => []);

// Distribute the cards to each player's pile
for (let i = 0; i < totalCards; i++) {
    piles[i % playersCount].push(deck.deck[i]);
}

 const gltfLoader = new GLTFLoader();
 gltfLoader.load('./components/kitchen_table.glb', function(glb) {
    const model = glb.scene;
    scene.add(model);
    model.rotateY(Math.PI / 2);
    model.scale.set(0.4, 0.4, 0.4);
    model.position.set(0.25, 0.15, 0);

    model.traverse(function(node) {
        if(node.isMesh) {
            node.receiveShadow = true;
        }
    })
    positionCards();
 });

 function positionCards() {
    // Check if piles are created
    if (piles.length === 0) {
        console.log("No piles available.");
        return;
    }

      // Create positions for the cards
      const pilePositions = [
      new THREE.Vector3(-1.5, 4, -1.25), // Adjusted Y for height above table
      new THREE.Vector3(1.5, 4, -1.25),
      new THREE.Vector3(0, 4, 1.75)
  ];

     // Position the cards for each player
     piles.forEach((pile, index) => {
        pile.forEach((card, cardIndex) => {
            const position = pilePositions[index];
            const offset = cardIndex * 0.005; // Stacking cards vertically

            // Position the card
            card.obj.position.set(position.x, position.y + offset, position.z);
            card.obj.scale.set(1, 1, 1); // Ensure cards are not scaled down
            card.obj.rotateX(90);
            scene.add(card.obj);

            // Debugging: Log card information
            console.log(`Positioned card ${cardIndex} for player ${index}:`, {
                position: card.obj.position,
                scale: card.obj.scale,
                visible: card.obj.visible,
            });
        });
    });
}

let centerPositions = [
    new THREE.Vector3(-0.5, 4, 0), // Position for Player 1's card in center
    new THREE.Vector3(0.5, 4, 0),  // Position for Player 2's card in center
    new THREE.Vector3(0, 4, -0.5)  // Position for Player 3's card in center
];
let displayedCards = []; // Store cards in the current round
let toMove = [];
let playerW = -1;

function animateCardMove(card, targetPosition) {
    const moveDuration = 1000; // 1-second animation for moving to the center
    const flipDuration = 500;  // Half-second animation for the flip
    const startPos = card.position.clone();
    const startTime = Date.now();

    // Set the initial rotation to face down
    card.rotation.set(Math.PI / 2, 0, 0); // Start with the card facing down

    // First phase: Move the card to the center
    function moveToCenter() {
        const elapsedTime = Date.now() - startTime;
        const t = Math.min(elapsedTime / moveDuration, 1);

        // Move the card to the center position
        card.position.lerpVectors(startPos, targetPosition, t);

        if (t < 1) {
            requestAnimationFrame(moveToCenter);
        } else {
            // Once at the center, start the flip after a brief delay
            setTimeout(flipCard, 200); // Delay before flipping
        }
    }

    // Second phase: Flip the card to show the face-up side
    function flipCard() {
        const flipStartTime = Date.now();

        function animateFlip() {
            const flipElapsed = Date.now() - flipStartTime;
            const t = Math.min(flipElapsed / flipDuration, 1);

            // Rotate the card along the X-axis to flip it 180 degrees (face-up)
            card.rotation.x = Math.PI / 2 * (1 - t); // Ends at 0 (face-up)

            if (t < 1) {
                requestAnimationFrame(animateFlip);
            } else {
                // Ensure it finishes exactly face-up and above the table
                card.rotation.x = -45; // Face-up
                card.position.y = targetPosition.y + 0.01; // Slightly above table height
            }
        }
        animateFlip();
    }

    // Start the movement to the center
    moveToCenter();
}

function updateScores() {
    document.getElementById("player1Score").innerText = piles[0] ? piles[0].length : 0;
    document.getElementById("player2Score").innerText = piles[1] ? piles[1].length : 0;
    document.getElementById("player3Score").innerText = piles[2] ? piles[2].length : 0;
}

function handleRound() {
    const cardsThisRound = piles.map((pile, index) => {
        if (pile.length > 0) {
            const card = pile.pop();
            displayedCards.push(card); // Track displayed cards on the table
            animateCardMove(card.obj, centerPositions[index]); // Animate card to center
            return { owner: index, card: card };
        }
        return null; // If no cards, mark player as out
    });
    // Filter out players who still have cards in this round
    const activePlayers = cardsThisRound.filter(entry => entry !== null);
    if (activePlayers.length < 2) {
        console.log(`Game over! Player ${activePlayers[0] ? activePlayers[0].owner + 1 : 'unknown'} wins!`);
        updateScores();
        playerW = activePlayers[0];
        toMove = displayedCards;
        return;
    }

    // Determine if there's a tie for the highest card
    const maxCardValue = Math.max(...activePlayers.map(entry => entry.card.value));
    const highestCards = activePlayers.filter(entry => entry.card.value === maxCardValue);

    if (highestCards.length === 1) {
        // Single winner: move all displayed cards to the winner's pile
        const winnerIndex = highestCards[0].owner;
        console.log(`Player ${winnerIndex + 1} wins this round!`); // Log winner
        if (piles[winnerIndex]) { // Ensure winner's pile exists
            piles[winnerIndex].unshift(...displayedCards);
            console.log(`Added ${displayedCards.length} cards to Player ${winnerIndex + 1}'s pile.`);
            playerW = winnerIndex;
            toMove = displayedCards;
        } else {
            console.error(`Winner index ${winnerIndex} is out of bounds for piles array.`);
        }
        displayedCards = []; // Clear cards on the table
    } else {
        // Tie detected - initiate a war
        console.log("War initiated!");
        handleWar(highestCards.map(entry => entry.owner));
    }
    updateScores();
}

function handleWar(playersInWar) {
    console.log("War initiated!");

    const warCards = [];
    playersInWar.forEach(playerIndex => {
        if (piles[playerIndex].length < 2) {
            // Player has fewer than 2 cards - use last available card as final face-up
            const finalCard = piles[playerIndex].pop();
            if (finalCard) {
                displayedCards.push(finalCard);
                warCards.push({ owner: playerIndex, card: finalCard });
                animateCardMove(finalCard.obj, centerPositions[playerIndex]);
            }
        } else {
            // Normal war play: one face-down and one face-up card
            const faceDownCard = piles[playerIndex].pop();
            displayedCards.push(faceDownCard);
            setTimeout(moveWarCardsFD, 2000, faceDownCard.obj, playerIndex);
            
            const faceUpCard = piles[playerIndex].pop();
            displayedCards.push(faceUpCard);
            warCards.push({ owner: playerIndex, card: faceUpCard });
            setTimeout(moveWarCardsFU, 3000, faceUpCard.obj, playerIndex);
        }
    });

    // Active players in the war with cards on the table
    const activeWarPlayers = warCards.filter(warCard => warCard !== null);
    if (activeWarPlayers.length < 2) {
        // Only one player remains after the war
        const solePlayer = activeWarPlayers[0].owner;
        piles[solePlayer].unshift(...displayedCards);
        playerW = solePlayer;
        toMove = displayedCards;
        displayedCards = [];
        console.log(`Player ${solePlayer + 1} wins all cards in the war!`);
        return;
    }

    // Check if there's a tie among war cards
    const maxWarValue = Math.max(...activeWarPlayers.map(warCard => warCard.card.value));
    const highestWarCards = activeWarPlayers.filter(warCard => warCard.card.value === maxWarValue);

    if (highestWarCards.length === 1) {
        // War winner
        const warWinner = highestWarCards[0].owner;
        piles[warWinner].unshift(...displayedCards);
        playerW = warWinner;
        toMove = displayedCards;
        displayedCards = [];
        console.log(`Player ${warWinner + 1} wins all cards in the war!`);
    } else {
        // War continues with new face-down and face-up cards
        handleWar(highestWarCards.map(warCard => warCard.owner));
    }
}


//Moving the Cards Back
function moveCardsToWinner(winner){
    if(winner == 0){
        toMove.forEach((card)=> {
            createMovement(card.obj, new THREE.Vector3(-1.5,4,-1.25),90); //-1.5,4,-1.25
        });
       
    } else if (winner == 1){
        toMove.forEach((card)=> {
            createMovement(card.obj, new THREE.Vector3(1.5,4,-1.25),90); //-1.25
        });
    } else if (winner == 2){
        toMove.forEach((card)=> {
            createMovement(card.obj, new THREE.Vector3(0,4,1.75),90); //1.75
        });
    }
    toMove = [];
}

function moveWarCardsFD(card, player){
    const moveDuration = 1000; // 1-second animation for moving to the center
    const flipDuration = 500;  // Half-second animation for the flip
    const startPos = card.position.clone();
    const startTime = Date.now();

    if(player == 0){
        var targetPosition = new THREE.Vector3(-1,4,0);
    } if(player == 1){
        var targetPosition = new THREE.Vector3(1,4,0);
    } if(player == 2)
        var targetPosition = new THREE.Vector3(0,4,-1.5);

    // First phase: Move the card to the center
    function moveToPile() {
        const elapsedTime = Date.now() - startTime;
        const t = Math.min(elapsedTime / moveDuration, 1);
        
        card.position.lerpVectors(startPos, targetPosition, t);

        if (t < 1) {
            requestAnimationFrame(moveToPile);
        }
    }

    moveToPile();

}

function moveWarCardsFU(card, player){
    if(player == 0){
        createMovement(card, new THREE.Vector3(-0.5,4,1),-45);
    } if(player == 1){
        createMovement(card, new THREE.Vector3(0.5,4,1),-45);
    } if(player == 2)
        createMovement(card, new THREE.Vector3(0,4,.5),-45);
}

function createMovement(card, targetPosition, angle){
    const moveDuration = 1000; // 1-second animation for moving to the center
    const flipDuration = 500;  // Half-second animation for the flip
    const startPos = card.position.clone();
    const startTime = Date.now();


    // First phase: Move the card to the center
    function moveToPile() {
        const elapsedTime = Date.now() - startTime;
        const t = Math.min(elapsedTime / moveDuration, 1);


        // Move the card to the center position
        card.position.lerpVectors(startPos, targetPosition, t);


        if (t < 1) {
            requestAnimationFrame(moveToPile);
        } else {
            // Once at the center, start the flip after a brief delay
            setTimeout(flipBack, 200); // Delay before flipping
        }
    }


    // Second phase: Flip the card to show the face-up side
    function flipBack() {
        const flipStartTime = Date.now();


        function animateFlip() {
            const flipElapsed = Date.now() - flipStartTime;
            const t = Math.min(flipElapsed / flipDuration, 1);


            // Rotate the card along the X-axis to flip it 180 degrees (face-up)
            card.rotation.x = Math.PI / 2 * (1 - t); // Ends at 0 (face-up)


            if (t < 1) {
                requestAnimationFrame(animateFlip);
            } else {
                // Ensure it finishes exactly face-up and above the table
                card.rotation.x = angle; // Face-down
                card.position.y = targetPosition.y + 0.01; // Slightly above table height
            }
        }
        animateFlip();
    }


    // Start the movement to the center
    moveToPile();
}

let num = 1;
// Key listener to start the round
document.addEventListener("keydown", (event) => {
    if (event.key === 'N' || event.key === 'n') {
        if(num == 1){
            handleRound();
            num++;
        } else {
            moveCardsToWinner(playerW);
            setTimeout(handleRound, 2000);
        }
        
    }
});

//Point light addition
const pLight = new THREE.PointLight(0xffffff, 1.0, 50, 2.0);
//pLight.position.set(0, 4, 0); // close enough to table to see its pos 
pLight.position.set(0, 6, 0); //starting pos
pLight.intensity = 10.0;
pLight.castShadow = true;
pLight.shadow.mapSize.width = 5000;
pLight.shadow.mapSize.length = 5000;
pLight.shadow.bias = -0.001
lights.push(pLight);
scene.add(pLight);

function shadowOnOff()
{
    for(let i = 0; i < lights.length; i++ )
    {
        lights[i].castShadow = !lights[i].castShadow;
    }
}

renderer.shadowMap.type = THREE.PCFSoftShadowMap; //to help with shadow smoothness


function keyHandler(e) {
  switch(e.keyCode){
    case 80: // The 'P' key
        pLight.visible = !pLight.visible;
    break;
    case 77: // The 'M' key 
        shadowOnOff();
    break;
    case 76: // The 'L' key
        ambientLight.visible = !ambientLight.visible;
    break;
    case 87: //The 'W' key //z = -3 at most
        if (pLight.position.z > -3) {
                pLight.position.z -= 0.1;
            }
    break;
    case 83: //The 'S' key // z = 5 at most
        if (pLight.position.z < 5) {
                pLight.position.z += 0.1;
            }
    break;
    case 65: //The 'A' key // x = -4 at most
        if (pLight.position.x > -4) {
                pLight.position.x -= 0.1;
            }
    break; 
    case 68: //The 'D' key // x = 4 at most
    if (pLight.position.x < 4) {
                pLight.position.x += 0.1;
            }
    break;
    case 89: //The 'Y' key //toggles directional light on and off
        directionalLight.visible = !directionalLight.visible;
    break;

  }
}
document.addEventListener( "keydown", keyHandler, false );


// Render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);

}
animate();    
</script>
</body>
</html>
